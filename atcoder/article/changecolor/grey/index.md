# 落灰した話

## 前置き

前回RatedのABC403で[入茶した](https://kito-qwer.github.io/blog/atcoder/article/changecolor/brown)のですが、早くも落灰したので記録します。
以下言い訳です。

## 端的な原因

WAしたB問題を放置したことです。

## ABC405参加記録

### A問題 Is it rated?

レーテッドかどうか判定する問題です。
テンプレートに大量に入れていたマクロによる謎の警告と実装のもたつきにより数分ロスしました。
なんとなく嫌な予感がしましたが、気にせず次に行きました。

```C++
int main(void) {
	intin(R, X); // int R, X; cin >> R >> X;
	if(X == 1)judicium(1600 <= R && R <= 2999); // Yes or No
	if(X == 2)judicium(1200 <= R && R <= 2399);
}
```

### B問題 Not All

末尾の要素を何度削除すると任意の1以上M以下の整数が1つ以上含まれていない状態にできるかという問題です。
この問題もまた実装にぐだった末、WAを1度取りました。
その後デバッグせずにC問題を解きはじめたのが間違いでした。
以下はWAのコードです。

```C++
int main(void) {
	intin(N, M);
	vector<int> A(N);
	vector<int> B(M + 1, 0);
	int count = 0;
	rep(i, N) {
		in(A[i]);
		B[A[i]]++;
	}
	rep(i, 1, M) {
		if(B[i] == 0) {
			outbr(0);
			return 0;
		}
	}
	for(int i = N - 1; 0 < i; i--) {  // 原因 0 <= i
		++count;
		if(B[A[i]] <= 1) {
			outbr(count);
			return 0;
		}
		B[A[i]]--;
	}
}
```

### C問題 Sum of Product

長さNの整数列Aに対して
Σ<sub>1≤i<j≤N</sub> A<sub>i</sub> A<sub>j</sub>
を求める問題です。
はじめは愚直にやろうと考えたのですが、なんとなく間に合わない気がしたので累積和を使用。
初めて累積和を使いました。

```C++
int main(void) {
	llin(N);
	vector<ll> A(N);
	vector<ll> B(N + 1, 0);
	ll ans = 0;
	rep(i, N) {
		in(A[i]);
		B[i + 1] = B[i] + A[i];
	}
	rep(i, N) {
		ans += ( B[N] - B[i + 1] ) * A[i];
	}
	outbr(ans);
}
```

### D問題 Escape Route

出口への最短ルートを示す問題です。
まずはじめにBFSを思いついたのですが、BFSは書けないので別の方法を試しました。
出口から一定距離の座標の空いている座標をルールに基づいて塗るという方法で、これは論理が間違っているため提出せずに、さらに別の方法を試しました。
ただ、その方法で実装した結果もWAでした。
そもそもO(max(H,W)HW)だったため通らないのは出す前からわかっていました。

### その後

D問題を提出したタイミングで開始後90分強、再提出していなかったB問題を見て数秒でバグを発見し提出、推定レートを見て絶望したというのが今回の流れです。

## 反省

立ち回りのミスといえばそうなのですが、茶色になった慢心や精進不足が根本たる原因といえそうです。
そもそもグリッドの問題が苦手なことやBFSが使えないということは、事前からわかっていたのであるからして、B問題を解かずにD問題を解こうとしたのは愚かであるとしか言いようがありません。
コンテスト中は着実に、誠実に問題を解いていくことを心に刻みたいと思います。
